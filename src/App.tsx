import React, { useState, useEffect, useCallback, useRef } from 'react'import { Routes, Route, useLocation } from 'react-router-dom'import './App.css'import { searchPhotos } from './api/pexels'import { RawPexelsPhotoPreview } from './types/photo'import MasonryGrid from './components/MasonryGrid'import PhotoDetail from './components/PhotoDetail'import SearchForm from './components/SearchForm'import { getPexelsApiKey } from './utils/env'function App() {	const location = useLocation()	const isHome = location.pathname === '/'	const [photos, setPhotos] = useState<RawPexelsPhotoPreview[]>([])	const [loading, setLoading] = useState<boolean>(false)	const [error, setError] = useState<string | null>(null)	const [page, setPage] = useState<number>(1)	const [query, setQuery] = useState<string>('animal')	// Ref to throttle multiple fetch calls during scrolling	const isFetching = useRef(false)	// Show error if the API key is missing	if (!getPexelsApiKey) {		return (			<p style={{ padding: '16px', color: 'red' }}>				VITE_PEXELS_API_KEY is missing in your .env file.			</p>		)	}	// Fetch photos for a specific page	const fetchPhotos = useCallback(		async (page: number, searchString: string) => {			// Set loading to true before making the API call			setLoading(true)			try {				// Fetch photos from API				const response = await searchPhotos(searchString, 30, page)				// Append newly fetched photos				setPhotos(prev =>					page === 1 ? response : [...prev, ...response]				)			} catch (error) {				console.error(`Failed to fetch photos: ${error}`)				setError('Failed to load photos. Please try again.')			} finally {				// Disable loading after API call has finished				setLoading(false)				// Reset throttle after fetch completes				isFetching.current = false			}		},		[]	)	// Get the initial load of photos once the component mounts or query changes	useEffect(() => {		fetchPhotos(1, query)	}, [fetchPhotos, query])	// Scroll event detects when we are approaching the bottom of the page	// and triggers another API call	useEffect(() => {		if (!isHome) return		let timeoutId: ReturnType<typeof setTimeout>		const handleScroll = () => {			// Check if the user is approaching the bottom of the page			const scrolledToBottom =				window.innerHeight + window.scrollY >=				document.body.offsetHeight - 300			// User is near the bottom and not already loading more photos			if (scrolledToBottom && !loading && !isFetching.current) {				// Block future triggers until current fetch finishes				isFetching.current = true				setPage(prev => prev + 1)				// Throttle page increase using a short timeout				timeoutId = setTimeout(() => {					setPage(prev => prev + 1)				}, 200)			}		}		window.addEventListener('scroll', handleScroll)		// Remove the event listener when component unmounts		return () => {			clearTimeout(timeoutId)			window.removeEventListener('scroll', handleScroll)		}	}, [loading])	// Fetch more photos when page changes	useEffect(() => {		if (page > 1) {			fetchPhotos(page, query)		}	}, [page, query, fetchPhotos])	const handleSearch = (value: string) => {		setPage(1)		setPhotos([])		setQuery(value)	}	// Show error if any	if (error) return <p>{error}</p>	return (		<div style={{ padding: '16px' }}>			{isHome && <SearchForm onSearch={handleSearch} query={query} />}			<Routes>				<Route path="/" element={<MasonryGrid photos={photos} />} />				<Route path="/photo/:id" element={<PhotoDetail />} />			</Routes>			{loading && (				<p style={{ textAlign: 'center' }}>Loading more photos...</p>			)}		</div>	)}export default App